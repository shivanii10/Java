Static keyword:

-variable : the object will share common space.
-block : it is executed whenever .class file is created. 
-method : static method doesn't need object for it's execution. 
          example : public static void main()
          It is used to mainly access methods independent of object creation.



import java.io.*;

import java.nio.file.*;

import java.util.*;

import java.util.stream.*;

public class ServiceFileFinder {

    public static void main(String[] args) {

        if (args.length < 1) {

            System.out.println("Usage: java ServiceFileFinder <directoryPath>");

            return;

        }

        String directoryPath = args[0];  // Root directory containing service files

        String keywordFilePath = "C:\\Users\\e5676342\\Downloads\\test\\URLs.txt";

        String outputFilePath = "Url&ServiceData.txt";

        try {

            List<String> keywords = readKeywords(keywordFilePath);

            Map<String, Set<String>> keywordToServices = findServiceFiles(directoryPath, keywords);

            saveOutput(keywordToServices, outputFilePath);

            System.out.println("Results saved to " + outputFilePath);

        } catch (IOException e) {

            System.out.println("Error: " + e.getMessage());

        }

    }

    // Reads keywords from output.txt

    private static List<String> readKeywords(String keywordFilePath) throws IOException {

        return Files.readAllLines(Paths.get(keywordFilePath)).stream()

                .filter(line -> !line.trim().isEmpty()) // Remove empty lines

                .collect(Collectors.toList());

    }

    // Searches for keywords in .service.ts files

    private static Map<String, Set<String>> findServiceFiles(String directoryPath, List<String> keywords) throws IOException {

        Map<String, Set<String>> keywordToServices = new LinkedHashMap<>();

        for (String keyword : keywords) {

            keywordToServices.put(keyword, new HashSet<>());

        }

        try (Stream<Path> paths = Files.walk(Paths.get(directoryPath))) {

            List<Path> serviceFiles = paths

                    .filter(path -> path.toString().endsWith(".service.ts"))

                    .collect(Collectors.toList());

            for (Path file : serviceFiles) {

                List<String> lines = Files.readAllLines(file);

                for (String keyword : keywords) {

                    if (lines.stream().anyMatch(line -> line.contains(keyword))) {

                        keywordToServices.get(keyword).add(file.getFileName().toString());

                    }

                }

            }

        }

        return keywordToServices;

    }

    // Saves results to output1.txt

    private static void saveOutput(Map<String, Set<String>> keywordToServices, String outputFilePath) throws IOException {

        List<String> outputLines = new ArrayList<>();

        for (Map.Entry<String, Set<String>> entry : keywordToServices.entrySet()) {

            outputLines.add(entry.getKey()); // Keyword on its own line

            if (entry.getValue().isEmpty()) {

                outputLines.add("None found");

            } else {

                outputLines.addAll(entry.getValue());

            }

            outputLines.add(""); // Add empty line for separation

        }

        Files.write(Paths.get(outputFilePath), outputLines);

    }

}
